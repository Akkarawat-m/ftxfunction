# -*- coding: utf-8 -*-
"""Finalize HW002 : Mean - 2SD  Logic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zV4z8GrEp43TL7PTp2sJ7KUKxu-kjWXh

# Initial Session
"""

#Akkarawat Mansap

#Credit1 : Nattapon Soomtha (กองทุนความมั่งคั่งแห่งชาติ Training)
#Credit2 : b2 spetsnaz club
#Credit3 : TEERACHAI RATTANABUNDITSAKUL

#----------------------------------------------------------------

# 1.Install library ที่เราจำเป็นจะต้องใช้ในการส่งคำสั่งและการตรวจเช็คออเดอร์
# - ccxt library ที่เป็นที่นิยมในการเชื่อม API กับ Exchange ต่างๆได้ง่ายขึ้นมาก
# - pandas library จะช่วยในการแปลงข้อมูลที่เราดึงมาจาก Exchange แปลงให้
#   เป็นตารางเพื่อให้ง่ายต่อการตรวจสอบออเดอร์
# - json จะใช้สำหรับการดึงข้อมูลที่เราต้องการมาจาก Exchange


#pip install ccxt
#pip install pandas

"""# Config Session"""

#print(dir(ccxt.ftx()))     # เช็คคำสั่งที่โบรคให้ใช้และ ccxt Provide

import ccxt
import json
import pandas as pd
import time

# api and secret

apiKey = ''         #input("Enter API Key:")      
secret = ''         #input("Enter Secret Key:")
subaccount = ''                                      #input("Enter Sub Account Name or 0 for Main:")


# exchange detail
exchange = ccxt.ftx({
    'apiKey' : apiKey ,'secret' : secret ,'enableRateLimit': True
})

# Sub Account Check

if subaccount == "0":
  print("This is Main Account")
else:
  exchange.headers = {
   'FTX-SUBACCOUNT': subaccount,
  }

def getPrice():
    pair = 'BTC-PERP'
    r1 = json.dumps(exchange.fetch_ticker(pair))
    dataPrice = json.loads(r1)
    #print(exchange)
    #print(pair + '=',dataPrice['last'])
    return (dataPrice['last'])

def showPending(pair):
    print("Your Pending Order")
    pendingOrder = pd.DataFrame(exchange.fetch_open_orders(pair),
                   columns=['id','datetime','status','symbol','type','side','price','amount','filled','average','remaining'])
    #display(pendingOrder)

def showMatched(pair):
    print("Your Matched Order")
    df2 = pd.DataFrame(exchange.fetchMyTrades(pair),
                       columns=['id','datetime', 'symbol','type','side','price','amount','cost'])
    #display(df2)
    return df2

def sendBuy():
  pair = 'BTC-PERP'                       # PRODUCT ที่เราต้องการเทรด ** # ไม่อยากใส่คู่ที่เทรดบ่อยๆ ใส่คู่ที่ต้องการเทรดแทน input เช่น pair = 'BTC-PERP'
  types = 'market'                         # ประเภทของคำสั่ง
  side = 'buy'                            # กำหนดฝั่ง BUY/SELL
  usd = 1                                 # กรณี Rebalance และต้องกรอกเป็น USD
  price = buySignal                       # ระดับราคาที่ต้องการ
  size_order = usd/price                  # ใส่ขนาดเป็น BTC, ถ้า Rebalance ให้ใส่เป็น usd/price # แล้วไปกรอกในตัวแปร usd แทน
  reduceOnly = False                      # ปิดโพซิชั่นเท่าจำนวนที่มีเท่านั้น (CREDIT : TY)
  postOnly =  False                       # วางโพซิชั่นเป็น MAKER เท่านั้น
  ioc = False                             # immidate or cancel เช่น ส่งคำสั่งไป Long 1000 market 
                                          # ถ้าไม่ได้ 1000 ก็ไม่เอา เช่นอาจจะเป็น 500 สองตัวก็ไม่เอา
  ## Send Order ##
  exchange.create_order(pair, types , side, size_order, price)

  ## Show Order Status##
  print("     ")
  showPending(pair)
  print("     ")
  showMatched(pair)

def sendSell():
  pair = 'BTC-PERP'                       # PRODUCT ที่เราต้องการเทรด ** # ไม่อยากใส่คู่ที่เทรดบ่อยๆ ใส่คู่ที่ต้องการเทรดแทน input เช่น pair = 'BTC-PERP'
  types = 'market'                         # ประเภทของคำสั่ง
  side = 'sell'                           # กำหนดฝั่ง BUY/SELL
  usd = 1                                 # กรณี Rebalance และต้องกรอกเป็น USD
  price = sellSignal                      # ระดับราคาที่ต้องการ
  size_order = usd/price                  # ใส่ขนาดเป็น BTC, ถ้า Rebalance ให้ใส่เป็น usd/price # แล้วไปกรอกในตัวแปร usd แทน
  reduceOnly = True                       # ปิดโพซิชั่นเท่าจำนวนที่มีเท่านั้น (CREDIT : TY)
  postOnly =  False                       # วางโพซิชั่นเป็น MAKER เท่านั้น
  ioc = False                             # immidate or cancel เช่น ส่งคำสั่งไป Long 1000 market 
                                          # ถ้าไม่ได้ 1000 ก็ไม่เอา เช่นอาจจะเป็น 500 สองตัวก็ไม่เอา

  ## Send Order ##
  exchange.create_order(pair, types , side, size_order, price)

  ## Show Order Status##
  print("     ")
  showPending(pair)
  print("     ")
  showMatched(pair)

"""# LOGIC SESSION"""

#Read Order To file 
buyRecord = []
with open("list.txt", "r") as f:
  for line in f:
    buyRecord.append(float(line.strip()))

print(buyRecord)


while True:
  # Check Time  
  print(time.ctime())

  # Update Price Data
  priceData = pd.DataFrame(exchange.fetch_ohlcv('BTC-PERP','5m'))

  # Display OHLCV Data
  #display(df4)
  #display(df4.iloc[-31:-1,[0,4]])

  # Buy Signal function

  buySignal = round((priceData.iloc[-31:-1,4].mean() - 2*(priceData.iloc[-31:-1,4].std()))*2) / 2
  #print(buySignal)

  # Sell Signal function

  sellSignal = round((priceData.iloc[-31:-1,4].mean())*2) / 2
  

  if getPrice() == buySignal and len(buyRecord) <= 17 and buyRecord.count(buySignal) < 1 :
    sendBuy()
    print('Buy 1 USD at' + str(buySignal))
    buyRecord.append(buySignal)
    with open("list.txt", "w") as f:      #Write Order To file 
      for ord in buyRecord:
        f.write(str(ord) +"\n")
  else:
    print(getPrice())
    print('waiting for buy signal ' + 'at ' + str(buySignal))

  if len(buyRecord) > 0:
    if getPrice() >= sellSignal:
      print('sell signal triggered at ' + str(sellSignal))
      minimumProfit = 10   #
      for ord in buyRecord:
        if getPrice() - ord > minimumProfit:
          sendSell()
          buyRecord.remove(ord)
          print(buyRecord)
          with open("list.txt", "w") as f:      #Write Order To file 
            for ord in buyRecord:
              f.write(str(ord) +"\n")
        else:
          print('Not Enough Profit ' + 'Minimum = ' + str(ord + minimumProfit))
          
    else:
      print('Waiting for sell signal ' + 'at ' + str(sellSignal))
  else: print('No Buy Order Record')
  print("  ")
  

      
  #time.sleep(60 - ((time.time() - starttime) % 60.0))
  time.sleep(0.5)